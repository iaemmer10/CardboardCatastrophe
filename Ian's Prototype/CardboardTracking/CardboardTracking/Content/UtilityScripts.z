class UtilityScripts : ZilchComponent
{
}



//Trace allows iteration speed to be faster by replacing the console.WriteLine with the infinitely superior trace command
struct Trace
{
    constructor(test : any)
    {
        Console.WriteLine(test);
    }
}

struct ValidateCogArray
{
    constructor(array : Array[Cog])
    {
        var i = 0;
        while(i < array.Count)
        {
            var cog = array.Get(i);
            // If this cog is not valid, remove it
            if(cog == null)
            {
                array.Set(i, array.Get(array.LastIndex));
                array.RemoveAt(array.LastIndex);
            }
            ++i;
        }
    }
}

struct Sort
{
    constructor(arrayToSort : Array[Integer])
    {
        arrayToSort.Sort(this.SmallestFirst);
        
    }
    function SmallestFirst(left : Integer, right : Integer) : Boolean
    {
        return left < right;
    }
}

struct StringSpinning
{
    
    
    constructor(space : Space, finalString : String, lineSpeed : Real, lineLength : Integer, textobj : Cog, convoManager : ConversationManager)
    {
        //Creates a new transform
        var blah = space.Create(Archetype.Find("Transform"));
        blah.RemoveComponentByName("Transform");
        blah.AddComponentByName("StringSpinner");
        blah.Name = "StringSpin";
        
        
        //Change it's values
        blah.StringSpinner.FinalString = finalString;
        blah.StringSpinner.LineSpeed = lineSpeed;
        blah.StringSpinner.LineLength = lineLength;
        blah.StringSpinner.TextObj = textobj;
        blah.StringSpinner.ConvoManager = convoManager;
        
        blah.StringSpinner.Initialize(null);
    }
}
class StringSpinner : ZilchComponent
{
    //Final String is what the final string should be when all is said and done.
    var FinalString : String = "Error: Not set to String";
    //LineSpeed is the rate, in seconds, at which each line of text is made. 
    var LineSpeed : Real = 1.0;
    //Line length is how long each line, in string characters, is.
    var LineLength : Integer = 20;
    
    var Timer : Real = 0.0;
    var LineIndex : Real = 0.0;
    
    var MathCalc : Real = 0.0;
    var TextObj : Cog = null;
    var ConvoManager : ConversationManager = null;
    
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        
        //Calculate how many characters per second need to be updated
        this.MathCalc = this.LineLength / this.LineSpeed;
    }
    function OnLogicUpdate(event :UpdateEvent)
    {
        
        
        this.Timer += event.Dt;
        this.LineIndex += this.MathCalc*event.Dt;
        if(this.LineIndex as Integer >= this.FinalString.Count)
        {
             //I could send out an event
            this.SetFinal();
            return;
        }
        var newString = this.FinalString.SubString(0, this.LineIndex as Integer);
        
        if(this.TextObj != null)
        {
            this.TextObj.SpriteText.Text = newString;
        }
    }
    
    function SetFinal()
    {
        if(this.TextObj != null)
        {
            this.TextObj.SpriteText.Text = this.FinalString;
            var textIcon = this.TextObj.Parent.FindChildByName("TextIcon");
            textIcon.Model.Visible = true;
            Zero.Disconnect(this.Space, Events.LogicUpdate, this);
            
            if(this.ConvoManager != null)
            {
                this.ConvoManager.InteractIndex += 1;
            }
            //Trace("SEND A CUSTOM EVENT RIGHT NOW");
            //Create a ScriptEvent
            var myOpenHUDInConversationsEvent = new OpenHUDInConversationsEvent();
            //Attach all available data
            //Dispatch it to owner
            this.GameSession.DispatchEvent("OpenHUDInConversationsEvent", myOpenHUDInConversationsEvent);
        }
        
        this.Owner.Destroy();
    }
    
    function FullWord(current : String, final : String): String
    {
        //I need a function that reads in a current string, and the final string, and appends the next full word onto the current string and returns it
        
        if(current.Count >= final.Count)
        {
            return final;
        }
        //Trace("This:         `current`");
        //grab the last letter after current ends in final 
        var char : String = final.SubString(current.Count, 1);
        //Trace(char);
        //for var i is 0, i++
        var i = 0;
        for ( i = 0; char != " "; i += 1)
        {
            
            if(current.Count + i >= final.Count)
            {
                i -= 1;
                break;
            }
            
            char = final.SubString(current.Count + i, 1);
            
            
        }
        var returnstring : String = final.SubString(0, current.Count + i);
        return returnstring;
        
        
        //if it is not space, grab the next one (repeat)
        //If space, return finalstring.substring(0, currentstring.count + i)
        //If larger than finalstring.count, return final string
    }
    function CheckIfNextWordIsNewLine(checkstring : String)
    {
        
        //I need to check if a full word crosses the THRESHOLD (Linelength) before reaching a space.
        //If it does, then I need to add spaces to FINAL STRING
        
        
        //At this point, I need to check if the last word of checkstring is already
        //I need to find the last space and the second to last space (the space before the last word)
        var lastSpace : String = checkstring.SubString(checkstring.Count -1, 1);
        var posofLastSpace : Integer = checkstring.Count;
        //var i is the count, i greater than 0, i--
        
        var i = checkstring.Count;
        for( i = checkstring.Count; i > 0; i-=1)
        {
            var char : String = checkstring.SubString(i -1, 1);
            if (char == " ")
            {
                //Trace("what");
                break;
                //At this point in time, i will be equal to the position of the last spot of a space
            }
        }
        //At this point, I need to croscheck i and posoflastspace against
        var endOfWord = checkstring.Count % this.LineLength;
        var startOfWord = i % this.LineLength;
        if (Math.Abs(endOfWord - startOfWord) > this.LineLength / 2)
        {
            //Trace(checkstring);
        }
        //if the last space is above an increment of newline and the second to last space is below the increment of new line, 
        //then add spaces to FINAL string until the first character of the word is on the newline 
    }
}